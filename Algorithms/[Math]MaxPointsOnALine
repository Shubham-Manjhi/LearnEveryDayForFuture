**Java Topic: LeetCode 149 â€“ Max Points on a Line**

---

âœ… 1. Definition and Purpose

â€¢ What is the concept?\
Given an array of points where `points[i] = [xi, yi]`, return the maximum number of points that lie on the same straight line.

â€¢ Why does it exist in Java?\
This problem involves geometry, hashing, and precision handling using slopes. It is a good test of edge case analysis and line calculations.

â€¢ What problem does it solve?\
Finds the largest subset of collinear points among a set of coordinates.

ðŸ§  Example: Input: [[1,1],[2,2],[3,3]] â†’ Output: 3

---

âœ… 2. Syntax and Structure

â€¢ Define `int maxPoints(int[][] points)`\
â€¢ Use nested loops to calculate slopes from one anchor point to others\
â€¢ Store slope frequency in a map

---

âœ… 3. Practical Examples

ðŸ”¹ Approach 1: HashMap with Reduced Fraction Slopes (Optimized)

ðŸ“Œ Idea: Use greatest common divisor (GCD) to normalize the slope to avoid floating-point precision issues.

```java
public class MaxPointsOnLine {
    public int maxPoints(int[][] points) {
        if (points.length <= 2) return points.length;
        int max = 0;

        for (int i = 0; i < points.length; i++) {
            Map<String, Integer> map = new HashMap<>();
            int samePoint = 1, currMax = 0;

            for (int j = i + 1; j < points.length; j++) {
                int dx = points[j][0] - points[i][0];
                int dy = points[j][1] - points[i][1];

                if (dx == 0 && dy == 0) {
                    samePoint++;
                    continue;
                }

                int gcd = gcd(dx, dy);
                dx /= gcd;
                dy /= gcd;

                String slope = dx + "/" + dy;
                map.put(slope, map.getOrDefault(slope, 0) + 1);
                currMax = Math.max(currMax, map.get(slope));
            }

            max = Math.max(max, currMax + samePoint);
        }

        return max;
    }

    private int gcd(int a, int b) {
        return b == 0 ? a : gcd(b, a % b);
    }
}
```

ðŸ“Œ Example:

```
Input: [[1,1],[2,2],[3,3],[0,4],[5,2],[1,3]]
Anchor = [1,1]
Slopes:
[2,2] â†’ 1/1
[3,3] â†’ 1/1
[0,4] â†’ -3/1
[5,2] â†’ 1/4
[1,3] â†’ 0/1
â†’ Max = 3 points on line with slope 1/1
```

ðŸ”¹ Approach 2: Brute Force with Double Precision (Less Optimal)

```java
public class MaxPointsOnLineDouble {
    public int maxPoints(int[][] points) {
        if (points.length <= 2) return points.length;
        int max = 0;

        for (int i = 0; i < points.length; i++) {
            Map<Double, Integer> map = new HashMap<>();
            int samePoint = 1, currMax = 0;

            for (int j = i + 1; j < points.length; j++) {
                if (points[i][0] == points[j][0] && points[i][1] == points[j][1]) {
                    samePoint++;
                    continue;
                }

                double slope = points[i][0] == points[j][0] ? Double.POSITIVE_INFINITY :
                               (double)(points[j][1] - points[i][1]) / (points[j][0] - points[i][0]);
                map.put(slope, map.getOrDefault(slope, 0) + 1);
                currMax = Math.max(currMax, map.get(slope));
            }

            max = Math.max(max, currMax + samePoint);
        }

        return max;
    }
}
```

ðŸ“Œ Why Less Optimal:

- Floating-point precision errors may miscount\

- Works fine for small inputs

---

âœ… 4. Internal Working

â€¢ Normalizing slopes ensures correctness and avoids floating-point errors\
â€¢ HashMap tracks frequency of identical slopes from a reference point\
â€¢ GCD helps convert slope into simplest form

Time Complexity: O(n^2)

Space Complexity: O(n) per iteration for slope map

---

âœ… 5. Best Practices

âœ” Normalize slopes with GCD to avoid rounding errors\
âœ” Handle vertical lines and overlapping points separately

---

âœ… 6. Related Concepts

- Slope geometry\

- GCD (Greatest Common Divisor)\

- HashMap frequency tracking

ðŸ§  Example: Geospatial mapping, clustering algorithms

---

âœ… 7. Interview & Real-world Use

ðŸ§  Interview Use:

- Demonstrates algorithmic precision, hash map logic, and edge handling

ðŸ¢ Real-world:

- Analyzing linear patterns in 2D data\

- Identifying trajectories or trends in simulations

---

âœ… 8. Common Errors & Debugging

âŒ Floating-point precision loss when comparing slopes\
âŒ Forgetting to handle duplicate points\
âŒ Incorrect GCD normalization

ðŸ§ª Debug Tip:

- Print GCD-reduced slope keys to verify correctness

---

âœ… 9. Java Version Updates

â€¢ Java 8+: Functional features possible, but classic loops preferred for clarity

---

âœ… 10. Practice and Application

ðŸ“ Practice on:

- LeetCode #149\

- Geometry hashing problems\

- Line detection algorithms

ðŸ— Apply in:

- Computer vision\

- Robotic path prediction\

- Shape fitting in scatter plots

---

