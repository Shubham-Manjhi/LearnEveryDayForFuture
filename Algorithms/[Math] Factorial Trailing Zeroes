**Java Topic: LeetCode 172 â€“ Factorial Trailing Zeroes**

---

âœ… 1. Definition and Purpose

â€¢ What is the concept?\
Given an integer n, return the number of trailing zeroes in n! (n factorial).

â€¢ Why does it exist in Java?\
This problem teaches mathematical optimization and how to avoid direct computation of large numbers.

â€¢ What problem does it solve?\
Calculates how many times 10 divides n! by counting factors of 5 (since 2s are more frequent).

ðŸ§  Example: Input: 5 â†’ Output: 1 (5! = 120)

---

âœ… 2. Syntax and Structure

â€¢ Define `int trailingZeroes(int n)`\
â€¢ Count how many multiples of 5, 25, 125... divide n

---

âœ… 3. Practical Examples

ðŸ”¹ Approach 1: Count Factors of 5 (Iterative)

ðŸ“Œ Why this works:\
Trailing zeroes in factorials are caused by 10s, and 10 = 2 Ã— 5.\
There are always more 2s than 5s in factorials, so the count of 5s determines the number of zeroes.

To count 5s:

- Each multiple of 5 adds one 5 (e.g., 5, 10, 15, ...)
- Multiples of 25 add an extra 5 (e.g., 25 = 5Ã—5, 50 = 5Ã—10)
- Multiples of 125 add two extra 5s (e.g., 125 = 5Ã—25)

We keep dividing n by 5, 25, 125... and accumulate the result.

```java
public class FactorialTrailingZeroes {
    public int trailingZeroes(int n) {
        int count = 0;
        while (n >= 5) {
            n /= 5;
            count += n;
        }
        return count;
    }
}
```

ðŸ“Œ Example: n = 100

```
100 / 5 = 20  â†’ 20 numbers give at least one 5
20 / 5 = 4    â†’ 4 numbers give one extra 5 (25, 50, 75, 100)
Total trailing zeroes = 20 + 4 = 24
```

ðŸ”¹ Approach 2: Recursive Factor Count

ðŸ“Œ Why this works:\
Same as approach 1, but uses recursion to simplify the breakdown.

At each recursive level, we calculate `n / 5` and recurse into `n / 5`.

```java
public class FactorialTrailingZeroesRecursive {
    public int trailingZeroes(int n) {
        if (n < 5) return 0;
        return n / 5 + trailingZeroes(n / 5);
    }
}
```

ðŸ“Œ Example: n = 100

```
100 / 5 = 20
20 / 5 = 4
4 / 5 = 0 (base case)
Total = 20 + 4 + 0 = 24
```

---

âœ… 4. Internal Working

â€¢ Each 10 = 2 \* 5, and 2s are always more abundant\
â€¢ Count all 5, 25, 125... as they contribute extra 5s

Time Complexity: O(logâ‚…n)

Space Complexity:

- Iterative: O(1)
- Recursive: O(logâ‚…n) call stack

---

âœ… 5. Best Practices

âœ” Donâ€™t compute n! directly â€” use mathematical approach\
âœ” Use iterative method to avoid stack overflow in recursion

---

âœ… 6. Related Concepts

- Prime factorization\

- Logarithmic math\

- Count trailing digits in number series

ðŸ§  Example: Compression of large digit formats, scientific formatting

---

âœ… 7. Interview & Real-world Use

ðŸ§  Interview Use:

- Tests ability to reduce factorial problems mathematically

ðŸ¢ Real-world:

- Scientific computation\

- Formatting outputs (e.g., scientific calculator formatting)

---

âœ… 8. Common Errors & Debugging

âŒ Calculating factorial directly (overflow)\
âŒ Only counting n / 5 (missing higher powers)

ðŸ§ª Debug Tip:

- Log each division result (n /= 5) and current count

---

âœ… 9. Java Version Updates

â€¢ No significant changes across Java versions\
â€¢ Java 8+: Streams possible but unnecessary for this simple logic

---

âœ… 10. Practice and Application

ðŸ“ Practice on:

- LeetCode #172\

- Prime count problems\

- Math-based factorial challenges

ðŸ— Apply in:

- Scientific calculators\

- Output padding\

- Factor-based analytics

---

