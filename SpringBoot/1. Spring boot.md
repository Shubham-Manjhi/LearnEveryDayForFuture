🌟 Spring Boot — Zero to Hero

📘 Chapter 1 — Spring & Spring Boot Fundamentals (School Management Example)

Learning goals (after finishing this chapter):
    •   Understand what a framework is and why Spring exists.
    •   Understand core Spring concepts: IoC, DI, Bean, ApplicationContext, Entities, Repositories, Controllers.
    •   Learn how Spring Boot auto-configures common components and how to run a simple, real-world REST API for a School Management System.
    •   See full, beginner-friendly code examples (entities, repositories, services, controllers), request/response samples, configuration, testing hints, and troubleshooting.

⸻

🎯 Target reader

This chapter assumes only basic Java knowledge (classes, objects, methods). Every new term is defined; whenever code appears, it is explained line-by-line.

⸻

🔎 1.1 Key Definitions (beginner-friendly)
    •   Framework: A foundation with pre-built components and rules for building applications (e.g., Spring). Think of it as a building kit with prewired plumbing and electricity.
    •   IoC (Inversion of Control): Instead of classes instantiating their dependencies, the framework creates and supplies them. The control of creating objects is inverted (framework controls it).
    •   DI (Dependency Injection): A pattern implementing IoC — dependencies are “injected” into objects. Common forms: constructor injection (preferred), setter injection, field injection.
    •   Bean: An object managed by the Spring container. Beans are created, configured and wired by Spring.
    •   ApplicationContext: The Spring container that holds bean definitions and manages their lifecycle.
    •   Entity: A Java class mapped to a database table using JPA annotations (e.g., @Entity).
    •   Repository: A data access component (interface) that performs DB operations. In Spring Data, repositories are often interfaces that extend JpaRepository.
    •   Controller: A class that handles HTTP requests and produces responses (e.g., REST endpoints).
    •   DTO (Data Transfer Object): A plain object used to exchange data across process boundaries (e.g., request or response payloads).
    •   REST (Representational State Transfer): An architectural style for HTTP APIs where resources are identified by URLs and manipulated via HTTP verbs (GET, POST, PUT, DELETE).
    •   CRUD: Create, Read, Update, Delete — basic operations for persistent resources.

⸻

🏫 1.2 Domain Overview — School Management System (conceptual)

We’ll build a small REST API that models these domain entities:
    •   Student — id, name, age, classroom assignment, parents
    •   Teacher — id, name, subject
    •   Classroom — id, room number, a teacher, list of students
    •   Parent — id, name, contact info, linked students

Relationships (simplified):
    •   A Student belongs to one Classroom (Many students → One classroom).
    •   A Classroom has one Teacher (Many classrooms → One teacher), or alternatively a teacher can be assigned to many classrooms.
    •   Student and Parent have a Many-to-Many relationship: one student can have multiple parents; one parent can have multiple students.

We’ll implement API endpoints to manage these resources.

⸻

🛠️ 1.3 Project Setup (Maven) — pom.xml (minimal)

Explanation: We use Maven to manage dependencies. This snippet contains the essential Spring Boot starters for web, data-jpa, H2 (in-memory DB for learning), actuator for monitoring, and test support.

<!-- pom.xml (excerpt) -->
<project xmlns="http://maven.apache.org/POM/4.0.0" ...>
  <modelVersion>4.0.0</modelVersion>
  <groupId>com.school</groupId>
  <artifactId>school-management</artifactId>
  <version>0.0.1-SNAPSHOT</version>
  <parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>3.1.0</version>
  </parent>

  <dependencies>
    <!-- Web (Spring MVC) -->
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <!-- JPA and H2 for quick demo -->
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
    <dependency>
      <groupId>com.h2database</groupId>
      <artifactId>h2</artifactId>
      <scope>runtime</scope>
    </dependency>

    <!-- Actuator (monitoring) -->
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>

    <!-- Test -->
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-test</artifactId>
      <scope>test</scope>
    </dependency>
  </dependencies>

  <properties>
    <java.version>17</java.version>
  </properties>
</project>

Note: Version numbers change over time — use the latest Spring Boot stable release when you create a real project.

⸻

📁 1.4 Recommended Project Structure

src/main/java/com/school/management
 ├─ SchoolApplication.java         # main class
 ├─ domain/
 │   ├─ Student.java
 │   ├─ Teacher.java
 │   ├─ Classroom.java
 │   └─ Parent.java
 ├─ repository/
 │   ├─ StudentRepository.java
 │   └─ TeacherRepository.java
 ├─ service/
 │   ├─ StudentService.java
 │   └─ StudentServiceImpl.java
 ├─ controller/
 │   └─ StudentController.java
 └─ dto/
     └─ StudentDTO.java


⸻

🧩 1.5 Main Application Class — SchoolApplication.java

package com.school.management;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class SchoolApplication {
    public static void main(String[] args) {
        SpringApplication.run(SchoolApplication.class, args);
    }
}

Explanation: @SpringBootApplication enables auto-configuration, component scanning, and Java-based configuration. The main method launches the embedded server and the Spring context.

⸻

🏷️ 1.6 Entities (JPA) — full examples with explanations

Student.java

package com.school.management.domain;

import jakarta.persistence.*;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "students")
public class Student {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String name;

    private Integer age;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "classroom_id")
    private Classroom classroom;

    @ManyToMany
    @JoinTable(name = "student_parents",
        joinColumns = @JoinColumn(name = "student_id"),
        inverseJoinColumns = @JoinColumn(name = "parent_id")
    )
    private Set<Parent> parents = new HashSet<>();

    // constructors, getters, setters
}

Notes:
    •   @Entity marks the class as a JPA entity.
    •   @Id and @GeneratedValue define the primary key.
    •   @ManyToOne indicates many students can belong to one classroom. LAZY fetch means related classroom data is loaded only when requested.
    •   @ManyToMany with @JoinTable models the student-parent relation.

Parent.java

package com.school.management.domain;

import jakarta.persistence.*;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "parents")
public class Parent {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String name;

    private String phone;

    @ManyToMany(mappedBy = "parents")
    private Set<Student> children = new HashSet<>();

    // constructors, getters, setters
}

Classroom.java

package com.school.management.domain;

import jakarta.persistence.*;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "classrooms")
public class Classroom {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String roomNumber;

    @OneToMany(mappedBy = "classroom")
    private Set<Student> students = new HashSet<>();

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "teacher_id")
    private Teacher teacher;

    // constructors, getters, setters
}

Teacher.java

package com.school.management.domain;

import jakarta.persistence.*;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "teachers")
public class Teacher {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    private String subject;

    @OneToMany(mappedBy = "teacher")
    private Set<Classroom> classrooms = new HashSet<>();

    // constructors, getters, setters
}

Tip: For learning, keep getters/setters and constructors concise. In production you can use Lombok to reduce boilerplate (@Data, @NoArgsConstructor, @AllArgsConstructor) but be aware of its trade-offs.

⸻

🔍 1.7 Repositories — Data access layer

Spring Data JPA reduces boilerplate for data access. You declare an interface and Spring provides the implementation at runtime.

package com.school.management.repository;

import com.school.management.domain.Student;
import org.springframework.data.jpa.repository.JpaRepository;

public interface StudentRepository extends JpaRepository<Student, Long> {
    // Derived query example: find by name
    List<Student> findByName(String name);
}

Explanation: JpaRepository<T, ID> gives CRUD methods: save(), findById(), findAll(), deleteById().

⸻

🧠 1.8 Services — Business logic with DI

Keep business logic in services and keep controllers thin.

package com.school.management.service;

import com.school.management.domain.Student;
import java.util.List;

public interface StudentService {
    Student create(Student s);
    Student getById(Long id);
    List<Student> getAll();
    Student update(Long id, Student s);
    void delete(Long id);
}

Implementation:

package com.school.management.service;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class StudentServiceImpl implements StudentService {
    private final StudentRepository studentRepository;

    // constructor injection — preferred because it's immutable and testable
    public StudentServiceImpl(StudentRepository studentRepository) {
        this.studentRepository = studentRepository;
    }

    @Override
    @Transactional
    public Student create(Student s) {
        return studentRepository.save(s);
    }

    @Override
    public Student getById(Long id) {
        return studentRepository.findById(id)
            .orElseThrow(() -> new ResourceNotFoundException("Student not found with id " + id));
    }

    @Override
    public List<Student> getAll() {
        return studentRepository.findAll();
    }

    @Override
    @Transactional
    public Student update(Long id, Student s) {
        Student existing = getById(id);
        existing.setName(s.getName());
        existing.setAge(s.getAge());
        // update other fields carefully
        return studentRepository.save(existing);
    }

    @Override
    @Transactional
    public void delete(Long id) {
        studentRepository.deleteById(id);
    }
}

Notes:
    •   @Service registers the class as a bean.
    •   Constructor injection avoids problems with @Autowired on fields and makes testing easier.
    •   @Transactional defines a transactional boundary — important for DB operations.
    •   Throwing ResourceNotFoundException will be handled by a global exception handler (see below).

⸻

🌐 1.9 Controllers — Expose HTTP endpoints

Keep controllers thin; delegate to services.

package com.school.management.controller;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import java.util.List;

@RestController
@RequestMapping("/api/students")
public class StudentController {
    private final StudentService studentService;

    public StudentController(StudentService studentService) {
        this.studentService = studentService;
    }

    @GetMapping
    public List<Student> getAll() {
        return studentService.getAll();
    }

    @GetMapping("/{id}")
    public Student getById(@PathVariable Long id) {
        return studentService.getById(id);
    }

    @PostMapping
    public ResponseEntity<Student> create(@RequestBody Student s) {
        Student created = studentService.create(s);
        return ResponseEntity.status(201).body(created);
    }

    @PutMapping("/{id}")
    public Student update(@PathVariable Long id, @RequestBody Student s) {
        return studentService.update(id, s);
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> delete(@PathVariable Long id) {
        studentService.delete(id);
        return ResponseEntity.noContent().build();
    }
}

HTTP concepts recap:
    •   GET /api/students — returns list.
    •   GET /api/students/{id} — returns single student by id.
    •   POST /api/students — creates a new student. Body contains JSON.
    •   PUT /api/students/{id} — updates an existing student.
    •   DELETE /api/students/{id} — removes a student.

Sample JSON for creating a student:

{
  "name": "Alice",
  "age": 10
}


⸻

🧾 1.10 Exception Handling — @ControllerAdvice

Create a global handler for ResourceNotFoundException and validation errors.

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<Map<String, String>> handleNotFound(ResourceNotFoundException ex) {
        Map<String, String> error = Map.of("error", ex.getMessage());
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);
    }

    // handle other exceptions (validation, bad requests, etc.)
}

Definition — @ControllerAdvice: A class that allows centralized exception handling across controllers.

⸻

⚙️ 1.11 Configuration — application.properties (H2 + JPA)

spring.datasource.url=jdbc:h2:mem:schooldb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=

spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true

server.port=8080

# enable actuator endpoints
management.endpoints.web.exposure.include=health,info

Notes:
    •   spring.jpa.hibernate.ddl-auto=update lets Hibernate create/update schema automatically — good for dev, not recommended for production migrations.
    •   spring.jpa.show-sql=true prints SQL statements for learning.
    •   H2 in-memory DB resets on app restart; useful for labs.

⸻

▶️ 1.12 Running the App and Quick Tests

Build and run:

mvn clean package
java -jar target/school-management-0.0.1-SNAPSHOT.jar

Alternatively for dev:

mvn spring-boot:run

Test endpoints with curl:
    •   Create student:

curl -X POST -H "Content-Type: application/json" -d '{"name":"Alice","age":10}' http://localhost:8080/api/students

    •   Get list:

curl http://localhost:8080/api/students

    •   Health check:

curl http://localhost:8080/actuator/health


⸻

🧪 1.13 Basic Testing Example (Controller slice)

Use @WebMvcTest to test controller behavior without starting the full application.

@WebMvcTest(StudentController.class)
class StudentControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private StudentService studentService; // mocked by Mockito

    @Test
    void whenGetAll_thenReturns200() throws Exception {
        when(studentService.getAll()).thenReturn(List.of(new Student(1L, "Alice", 10)));

        mockMvc.perform(get("/api/students"))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$[0].name").value("Alice"));
    }
}

Explanation:
    •   @WebMvcTest loads only the MVC layer.
    •   MockMvc performs HTTP requests in tests.
    •   @MockBean replaces the service bean with a Mockito mock.

⸻

⚠️ 1.14 Common Startup/Runtime Problems & Solutions
    •   Port 8080 already in use → change server.port or stop the occupying process.
    •   NoSuchBeanDefinitionException → ensure classes annotated with @Service / @Repository / @Controller are in packages scanned by @SpringBootApplication.
    •   LazyInitializationException → accessing LAZY relationships outside transaction; fix by using DTOs, fetch joins, or keeping transactional boundary during read.
    •   DataIntegrityViolationException → violates DB constraints — validate input or adjust schema.

⸻

🧭 1.15 Exercises & Mini-Labs (step-by-step tasks)
    1.  Complete Teacher & Classroom APIs — implement repositories, services and controllers for Teacher and Classroom (CRUD).
    2.  Assign teacher to classroom — endpoint POST /api/classrooms/{id}/assign-teacher/{teacherId}.
    3.  Search students by name — add repository method findByNameContainingIgnoreCase(String name) and expose as GET /api/students?name=ali.
    4.  Add validation — use @Valid and @NotNull, @Size on DTOs and handle MethodArgumentNotValidException globally.
    5.  Implement pagination — return Page<Student> using Pageable in repository and controller.
    6.  Seed data — create data.sql to insert sample students, teachers, parents on startup.

⸻

📚 1.16 Learning Notes & Best Practices (beginner → pro)
    •   Prefer constructor injection — easier to test and immutable.
    •   Keep controllers thin — controllers should orchestrate, services should contain business logic.
    •   Use DTOs for external API surface to decouple internal domain model from API contract.
    •   Avoid exposing entities directly in public APIs in real apps — shown here for simplicity.
    •   Use proper migration tools (Flyway/Liquibase) for DB schema changes in real projects; ddl-auto=update is ok for labs only.

⸻

🧾 1.17 Full Glossary (terms introduced)
    •   Entity, Repository, Service, Controller, DTO — described earlier with examples.
    •   LAZY vs EAGER fetch — LAZY loads relations only on demand; EAGER loads immediately (can cause performance issues).
    •   Transaction — a unit of work that either fully completes or fully rolls back.
    •   Migrations — version-controlled DB schema upgrades (Flyway/Liquibase).

⸻

✅ 1.18 What I updated for you

This chapter now contains a complete, beginner-friendly walkthrough of a School Management REST API built with Spring Boot: definitions, conceptual diagrams (described), full code snippets for entities, repository, service, controller, configuration, running instructions, testing example, and exercises.

⸻

🔜 Next options (pick one)
    •   I can generate the complete runnable project files (all .java, pom.xml, application.properties, data.sql) and prepare a ZIP for download.
    •   I can move to Chapter 2 (Project Setup & Build Tools) and show Maven vs Gradle in-depth and create the project using Spring Initializr.
    •   I can expand any subsection above (e.g., deep dive into JPA relationships, DTO mapping, validation, or testing).

Tell me which you want and I’ll continue — I already updated the Canvas with this new Chapter 1 content.