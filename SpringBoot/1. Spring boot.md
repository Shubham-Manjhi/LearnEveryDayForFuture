üåü Spring Boot ‚Äî Zero to Hero

üìò Chapter 1 ‚Äî Spring & Spring Boot Fundamentals (School Management Example)

Learning goals (after finishing this chapter):
    ‚Ä¢   Understand what a framework is and why Spring exists.
    ‚Ä¢   Understand core Spring concepts: IoC, DI, Bean, ApplicationContext, Entities, Repositories, Controllers.
    ‚Ä¢   Learn how Spring Boot auto-configures common components and how to run a simple, real-world REST API for a School Management System.
    ‚Ä¢   See full, beginner-friendly code examples (entities, repositories, services, controllers), request/response samples, configuration, testing hints, and troubleshooting.

‚∏ª

üéØ Target reader

This chapter assumes only basic Java knowledge (classes, objects, methods). Every new term is defined; whenever code appears, it is explained line-by-line.

‚∏ª

üîé 1.1 Key Definitions (beginner-friendly)
    ‚Ä¢   Framework: A foundation with pre-built components and rules for building applications (e.g., Spring). Think of it as a building kit with prewired plumbing and electricity.
    ‚Ä¢   IoC (Inversion of Control): Instead of classes instantiating their dependencies, the framework creates and supplies them. The control of creating objects is inverted (framework controls it).
    ‚Ä¢   DI (Dependency Injection): A pattern implementing IoC ‚Äî dependencies are ‚Äúinjected‚Äù into objects. Common forms: constructor injection (preferred), setter injection, field injection.
    ‚Ä¢   Bean: An object managed by the Spring container. Beans are created, configured and wired by Spring.
    ‚Ä¢   ApplicationContext: The Spring container that holds bean definitions and manages their lifecycle.
    ‚Ä¢   Entity: A Java class mapped to a database table using JPA annotations (e.g., @Entity).
    ‚Ä¢   Repository: A data access component (interface) that performs DB operations. In Spring Data, repositories are often interfaces that extend JpaRepository.
    ‚Ä¢   Controller: A class that handles HTTP requests and produces responses (e.g., REST endpoints).
    ‚Ä¢   DTO (Data Transfer Object): A plain object used to exchange data across process boundaries (e.g., request or response payloads).
    ‚Ä¢   REST (Representational State Transfer): An architectural style for HTTP APIs where resources are identified by URLs and manipulated via HTTP verbs (GET, POST, PUT, DELETE).
    ‚Ä¢   CRUD: Create, Read, Update, Delete ‚Äî basic operations for persistent resources.

‚∏ª

üè´ 1.2 Domain Overview ‚Äî School Management System (conceptual)

We‚Äôll build a small REST API that models these domain entities:
    ‚Ä¢   Student ‚Äî id, name, age, classroom assignment, parents
    ‚Ä¢   Teacher ‚Äî id, name, subject
    ‚Ä¢   Classroom ‚Äî id, room number, a teacher, list of students
    ‚Ä¢   Parent ‚Äî id, name, contact info, linked students

Relationships (simplified):
    ‚Ä¢   A Student belongs to one Classroom (Many students ‚Üí One classroom).
    ‚Ä¢   A Classroom has one Teacher (Many classrooms ‚Üí One teacher), or alternatively a teacher can be assigned to many classrooms.
    ‚Ä¢   Student and Parent have a Many-to-Many relationship: one student can have multiple parents; one parent can have multiple students.

We‚Äôll implement API endpoints to manage these resources.

‚∏ª

üõ†Ô∏è 1.3 Project Setup (Maven) ‚Äî pom.xml (minimal)

Explanation: We use Maven to manage dependencies. This snippet contains the essential Spring Boot starters for web, data-jpa, H2 (in-memory DB for learning), actuator for monitoring, and test support.

<!-- pom.xml (excerpt) -->
<project xmlns="http://maven.apache.org/POM/4.0.0" ...>
  <modelVersion>4.0.0</modelVersion>
  <groupId>com.school</groupId>
  <artifactId>school-management</artifactId>
  <version>0.0.1-SNAPSHOT</version>
  <parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>3.1.0</version>
  </parent>

  <dependencies>
    <!-- Web (Spring MVC) -->
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <!-- JPA and H2 for quick demo -->
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
    <dependency>
      <groupId>com.h2database</groupId>
      <artifactId>h2</artifactId>
      <scope>runtime</scope>
    </dependency>

    <!-- Actuator (monitoring) -->
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>

    <!-- Test -->
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-test</artifactId>
      <scope>test</scope>
    </dependency>
  </dependencies>

  <properties>
    <java.version>17</java.version>
  </properties>
</project>

Note: Version numbers change over time ‚Äî use the latest Spring Boot stable release when you create a real project.

‚∏ª

üìÅ 1.4 Recommended Project Structure

src/main/java/com/school/management
 ‚îú‚îÄ SchoolApplication.java         # main class
 ‚îú‚îÄ domain/
 ‚îÇ   ‚îú‚îÄ Student.java
 ‚îÇ   ‚îú‚îÄ Teacher.java
 ‚îÇ   ‚îú‚îÄ Classroom.java
 ‚îÇ   ‚îî‚îÄ Parent.java
 ‚îú‚îÄ repository/
 ‚îÇ   ‚îú‚îÄ StudentRepository.java
 ‚îÇ   ‚îî‚îÄ TeacherRepository.java
 ‚îú‚îÄ service/
 ‚îÇ   ‚îú‚îÄ StudentService.java
 ‚îÇ   ‚îî‚îÄ StudentServiceImpl.java
 ‚îú‚îÄ controller/
 ‚îÇ   ‚îî‚îÄ StudentController.java
 ‚îî‚îÄ dto/
     ‚îî‚îÄ StudentDTO.java


‚∏ª

üß© 1.5 Main Application Class ‚Äî SchoolApplication.java

package com.school.management;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class SchoolApplication {
    public static void main(String[] args) {
        SpringApplication.run(SchoolApplication.class, args);
    }
}

Explanation: @SpringBootApplication enables auto-configuration, component scanning, and Java-based configuration. The main method launches the embedded server and the Spring context.

‚∏ª

üè∑Ô∏è 1.6 Entities (JPA) ‚Äî full examples with explanations

Student.java

package com.school.management.domain;

import jakarta.persistence.*;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "students")
public class Student {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String name;

    private Integer age;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "classroom_id")
    private Classroom classroom;

    @ManyToMany
    @JoinTable(name = "student_parents",
        joinColumns = @JoinColumn(name = "student_id"),
        inverseJoinColumns = @JoinColumn(name = "parent_id")
    )
    private Set<Parent> parents = new HashSet<>();

    // constructors, getters, setters
}

Notes:
    ‚Ä¢   @Entity marks the class as a JPA entity.
    ‚Ä¢   @Id and @GeneratedValue define the primary key.
    ‚Ä¢   @ManyToOne indicates many students can belong to one classroom. LAZY fetch means related classroom data is loaded only when requested.
    ‚Ä¢   @ManyToMany with @JoinTable models the student-parent relation.

Parent.java

package com.school.management.domain;

import jakarta.persistence.*;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "parents")
public class Parent {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String name;

    private String phone;

    @ManyToMany(mappedBy = "parents")
    private Set<Student> children = new HashSet<>();

    // constructors, getters, setters
}

Classroom.java

package com.school.management.domain;

import jakarta.persistence.*;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "classrooms")
public class Classroom {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String roomNumber;

    @OneToMany(mappedBy = "classroom")
    private Set<Student> students = new HashSet<>();

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "teacher_id")
    private Teacher teacher;

    // constructors, getters, setters
}

Teacher.java

package com.school.management.domain;

import jakarta.persistence.*;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "teachers")
public class Teacher {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    private String subject;

    @OneToMany(mappedBy = "teacher")
    private Set<Classroom> classrooms = new HashSet<>();

    // constructors, getters, setters
}

Tip: For learning, keep getters/setters and constructors concise. In production you can use Lombok to reduce boilerplate (@Data, @NoArgsConstructor, @AllArgsConstructor) but be aware of its trade-offs.

‚∏ª

üîç 1.7 Repositories ‚Äî Data access layer

Spring Data JPA reduces boilerplate for data access. You declare an interface and Spring provides the implementation at runtime.

package com.school.management.repository;

import com.school.management.domain.Student;
import org.springframework.data.jpa.repository.JpaRepository;

public interface StudentRepository extends JpaRepository<Student, Long> {
    // Derived query example: find by name
    List<Student> findByName(String name);
}

Explanation: JpaRepository<T, ID> gives CRUD methods: save(), findById(), findAll(), deleteById().

‚∏ª

üß† 1.8 Services ‚Äî Business logic with DI

Keep business logic in services and keep controllers thin.

package com.school.management.service;

import com.school.management.domain.Student;
import java.util.List;

public interface StudentService {
    Student create(Student s);
    Student getById(Long id);
    List<Student> getAll();
    Student update(Long id, Student s);
    void delete(Long id);
}

Implementation:

package com.school.management.service;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class StudentServiceImpl implements StudentService {
    private final StudentRepository studentRepository;

    // constructor injection ‚Äî preferred because it's immutable and testable
    public StudentServiceImpl(StudentRepository studentRepository) {
        this.studentRepository = studentRepository;
    }

    @Override
    @Transactional
    public Student create(Student s) {
        return studentRepository.save(s);
    }

    @Override
    public Student getById(Long id) {
        return studentRepository.findById(id)
            .orElseThrow(() -> new ResourceNotFoundException("Student not found with id " + id));
    }

    @Override
    public List<Student> getAll() {
        return studentRepository.findAll();
    }

    @Override
    @Transactional
    public Student update(Long id, Student s) {
        Student existing = getById(id);
        existing.setName(s.getName());
        existing.setAge(s.getAge());
        // update other fields carefully
        return studentRepository.save(existing);
    }

    @Override
    @Transactional
    public void delete(Long id) {
        studentRepository.deleteById(id);
    }
}

Notes:
    ‚Ä¢   @Service registers the class as a bean.
    ‚Ä¢   Constructor injection avoids problems with @Autowired on fields and makes testing easier.
    ‚Ä¢   @Transactional defines a transactional boundary ‚Äî important for DB operations.
    ‚Ä¢   Throwing ResourceNotFoundException will be handled by a global exception handler (see below).

‚∏ª

üåê 1.9 Controllers ‚Äî Expose HTTP endpoints

Keep controllers thin; delegate to services.

package com.school.management.controller;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import java.util.List;

@RestController
@RequestMapping("/api/students")
public class StudentController {
    private final StudentService studentService;

    public StudentController(StudentService studentService) {
        this.studentService = studentService;
    }

    @GetMapping
    public List<Student> getAll() {
        return studentService.getAll();
    }

    @GetMapping("/{id}")
    public Student getById(@PathVariable Long id) {
        return studentService.getById(id);
    }

    @PostMapping
    public ResponseEntity<Student> create(@RequestBody Student s) {
        Student created = studentService.create(s);
        return ResponseEntity.status(201).body(created);
    }

    @PutMapping("/{id}")
    public Student update(@PathVariable Long id, @RequestBody Student s) {
        return studentService.update(id, s);
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> delete(@PathVariable Long id) {
        studentService.delete(id);
        return ResponseEntity.noContent().build();
    }
}

HTTP concepts recap:
    ‚Ä¢   GET /api/students ‚Äî returns list.
    ‚Ä¢   GET /api/students/{id} ‚Äî returns single student by id.
    ‚Ä¢   POST /api/students ‚Äî creates a new student. Body contains JSON.
    ‚Ä¢   PUT /api/students/{id} ‚Äî updates an existing student.
    ‚Ä¢   DELETE /api/students/{id} ‚Äî removes a student.

Sample JSON for creating a student:

{
  "name": "Alice",
  "age": 10
}


‚∏ª

üßæ 1.10 Exception Handling ‚Äî @ControllerAdvice

Create a global handler for ResourceNotFoundException and validation errors.

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<Map<String, String>> handleNotFound(ResourceNotFoundException ex) {
        Map<String, String> error = Map.of("error", ex.getMessage());
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);
    }

    // handle other exceptions (validation, bad requests, etc.)
}

Definition ‚Äî @ControllerAdvice: A class that allows centralized exception handling across controllers.

‚∏ª

‚öôÔ∏è 1.11 Configuration ‚Äî application.properties (H2 + JPA)

spring.datasource.url=jdbc:h2:mem:schooldb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=

spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true

server.port=8080

# enable actuator endpoints
management.endpoints.web.exposure.include=health,info

Notes:
    ‚Ä¢   spring.jpa.hibernate.ddl-auto=update lets Hibernate create/update schema automatically ‚Äî good for dev, not recommended for production migrations.
    ‚Ä¢   spring.jpa.show-sql=true prints SQL statements for learning.
    ‚Ä¢   H2 in-memory DB resets on app restart; useful for labs.

‚∏ª

‚ñ∂Ô∏è 1.12 Running the App and Quick Tests

Build and run:

mvn clean package
java -jar target/school-management-0.0.1-SNAPSHOT.jar

Alternatively for dev:

mvn spring-boot:run

Test endpoints with curl:
    ‚Ä¢   Create student:

curl -X POST -H "Content-Type: application/json" -d '{"name":"Alice","age":10}' http://localhost:8080/api/students

    ‚Ä¢   Get list:

curl http://localhost:8080/api/students

    ‚Ä¢   Health check:

curl http://localhost:8080/actuator/health


‚∏ª

üß™ 1.13 Basic Testing Example (Controller slice)

Use @WebMvcTest to test controller behavior without starting the full application.

@WebMvcTest(StudentController.class)
class StudentControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private StudentService studentService; // mocked by Mockito

    @Test
    void whenGetAll_thenReturns200() throws Exception {
        when(studentService.getAll()).thenReturn(List.of(new Student(1L, "Alice", 10)));

        mockMvc.perform(get("/api/students"))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$[0].name").value("Alice"));
    }
}

Explanation:
    ‚Ä¢   @WebMvcTest loads only the MVC layer.
    ‚Ä¢   MockMvc performs HTTP requests in tests.
    ‚Ä¢   @MockBean replaces the service bean with a Mockito mock.

‚∏ª

‚ö†Ô∏è 1.14 Common Startup/Runtime Problems & Solutions
    ‚Ä¢   Port 8080 already in use ‚Üí change server.port or stop the occupying process.
    ‚Ä¢   NoSuchBeanDefinitionException ‚Üí ensure classes annotated with @Service / @Repository / @Controller are in packages scanned by @SpringBootApplication.
    ‚Ä¢   LazyInitializationException ‚Üí accessing LAZY relationships outside transaction; fix by using DTOs, fetch joins, or keeping transactional boundary during read.
    ‚Ä¢   DataIntegrityViolationException ‚Üí violates DB constraints ‚Äî validate input or adjust schema.

‚∏ª

üß≠ 1.15 Exercises & Mini-Labs (step-by-step tasks)
    1.  Complete Teacher & Classroom APIs ‚Äî implement repositories, services and controllers for Teacher and Classroom (CRUD).
    2.  Assign teacher to classroom ‚Äî endpoint POST /api/classrooms/{id}/assign-teacher/{teacherId}.
    3.  Search students by name ‚Äî add repository method findByNameContainingIgnoreCase(String name) and expose as GET /api/students?name=ali.
    4.  Add validation ‚Äî use @Valid and @NotNull, @Size on DTOs and handle MethodArgumentNotValidException globally.
    5.  Implement pagination ‚Äî return Page<Student> using Pageable in repository and controller.
    6.  Seed data ‚Äî create data.sql to insert sample students, teachers, parents on startup.

‚∏ª

üìö 1.16 Learning Notes & Best Practices (beginner ‚Üí pro)
    ‚Ä¢   Prefer constructor injection ‚Äî easier to test and immutable.
    ‚Ä¢   Keep controllers thin ‚Äî controllers should orchestrate, services should contain business logic.
    ‚Ä¢   Use DTOs for external API surface to decouple internal domain model from API contract.
    ‚Ä¢   Avoid exposing entities directly in public APIs in real apps ‚Äî shown here for simplicity.
    ‚Ä¢   Use proper migration tools (Flyway/Liquibase) for DB schema changes in real projects; ddl-auto=update is ok for labs only.

‚∏ª

üßæ 1.17 Full Glossary (terms introduced)
    ‚Ä¢   Entity, Repository, Service, Controller, DTO ‚Äî described earlier with examples.
    ‚Ä¢   LAZY vs EAGER fetch ‚Äî LAZY loads relations only on demand; EAGER loads immediately (can cause performance issues).
    ‚Ä¢   Transaction ‚Äî a unit of work that either fully completes or fully rolls back.
    ‚Ä¢   Migrations ‚Äî version-controlled DB schema upgrades (Flyway/Liquibase).

‚∏ª

‚úÖ 1.18 What I updated for you

This chapter now contains a complete, beginner-friendly walkthrough of a School Management REST API built with Spring Boot: definitions, conceptual diagrams (described), full code snippets for entities, repository, service, controller, configuration, running instructions, testing example, and exercises.

‚∏ª

üîú Next options (pick one)
    ‚Ä¢   I can generate the complete runnable project files (all .java, pom.xml, application.properties, data.sql) and prepare a ZIP for download.
    ‚Ä¢   I can move to Chapter 2 (Project Setup & Build Tools) and show Maven vs Gradle in-depth and create the project using Spring Initializr.
    ‚Ä¢   I can expand any subsection above (e.g., deep dive into JPA relationships, DTO mapping, validation, or testing).

Tell me which you want and I‚Äôll continue ‚Äî I already updated the Canvas with this new Chapter 1 content.